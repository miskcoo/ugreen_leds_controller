#!/usr/bin/bash

# led-disk mapping (see https://github.com/miskcoo/ugreen_dx4600_leds_controller/pull/4)
mapping_method=hctl  # hctl, serial
led_map=(disk1 disk2 disk3 disk4 disk5 disk6 disk7 disk8)

# hctl, $> lsblk -S -x hctl -o hctl,serial,name 
# NOTE: It is reported that the order below should be adjusted for each model. 
#       Please check the disk mapping section in https://github.com/miskcoo/ugreen_dx4600_leds_controller/blob/master/README.md.
hctl_map=("0:0:0:0" "1:0:0:0" "2:0:0:0" "3:0:0:0" "4:0:0:0" "5:0:0:0" "6:0:0:0" "7:0:0:0")
if which dmidecode; then
    product_name=$(dmidecode --string system-product-name)
    case "${product_name}" in 
        "DXP6800 Pro")
          echo "Found UGREEN DXP6800 Pro" 
          hctl_map=("2:0:0:0" "3:0:0:0" "4:0:0:0" "5:0:0:0" "0:0:0:0" "1:0:0:0")
          ;;
        "DX4600 Pro")
          echo "Found UGREEN DX4600 Pro" 
          # using the default mapping
          ;;
        "DXP8800 Plus")
          echo "Found UGREEN DXP8800 Plus" 
          # using the default mapping
          ;;
        *)
          if [[ "${mapping_method}" = "hctl" ]]; then
              echo "Using the default HCTL order. Please check it maps to your disk slots correctly."
              echo "If you confirm that the HCTL order is correct, or find it is different, you can submit an issue to let us know, so we can update the script."
              echo "(Read the disk mapping section in https://github.com/miskcoo/ugreen_dx4600_leds_controller/blob/master/README.md for more details)"
          fi
          ;;
    esac
elif [[ "${mapping_method}" = "hctl" ]]; then
    echo "installing the tool `dmidecode` is suggested; otherwise the script cannot detect your device and adjust the hctl_map"
fi 
# serial number, $> lsblk -S -x hctl -o hctl,serial,name 
serial_map=("placeholder0" "placeholder1" "placeholder2" "placeholder3" "placeholder4" "placeholder5" "placeholder6" "placeholder7")
declare -A devices

# monitor dist SMART information
CHECK_SMART=true
# polling rate for smartctl. roughly 360 seconds by default
smart_poll_interval=3600




{ lsmod | grep ledtrig_oneshot ; } || modprobe -v ledtrig_oneshot

sleep 2

echo Enumerating disks based on $mapping_method...
declare -A dev_map
while read line
do
    blk_line=($line)
    if [[ $mapping_method = hctl ]]; then
        key=${blk_line[1]}
        val=${blk_line[0]}
    elif [[ $mapping_method = serial ]]; then
        key=${blk_line[1]}
        val=${blk_line[0]}
    else
        echo Unsupported mapping method: ${mapping_method}
        exit 1
    fi
    dev_map[${key}]=${val}
    echo $mapping_method ${key} ">>" ${dev_map[${key}]}
done <<< "$(lsblk -S -o name,${mapping_method} | tail -n +2)"

for i in "${!led_map[@]}"; do
    led=${led_map[i]} 
    if [[ -d /sys/class/leds/$led ]]; then
        echo oneshot > /sys/class/leds/$led/trigger
        echo 1 > /sys/class/leds/$led/invert
        echo 100 > /sys/class/leds/$led/delay_on
        echo 100 > /sys/class/leds/$led/delay_off
        echo "255 255 255" > /sys/class/leds/$led/color

        # find corresponding device
        _tmp_str=${mapping_method}_map[@]
        _tmp_arr=(${!_tmp_str})
        dev=${dev_map[${_tmp_arr[i]}]}
        if [[ -f /sys/class/block/${dev}/stat ]]; then
            devices[$led]=${dev}
        else
            # turn off the led if no disk installed on this slot
            echo 0 > /sys/class/leds/$led/brightness
            echo none > /sys/class/leds/$led/trigger
        fi
    fi
done

declare -A diskio_data_r
declare -A diskio_data_w
let loop_cnt=0
while true; do
    for led in "${!devices[@]}"; do
        dev=${devices[$led]}
        diskio_old_r=${diskio_data_r[$led]}
        diskio_old_w=${diskio_data_w[$led]}

        if [[ "$(cat /sys/class/leds/$led/color)" = "255 0 0" ]]; then
            continue;
        fi

        if [[ ! -f /sys/class/block/${dev}/stat ]]; then
            if [[ -f /sys/class/leds/$led/color ]]; then 
                echo "255 0 0" > /sys/class/leds/$led/color
                echo Disk /dev/$dev went offline at $(date +%Y-%m-%d' '%H:%M:%S)
                continue
            fi
        fi

        # check disk health
        if [ "$CHECK_SMART" = true ] && [[ ${loop_cnt} -eq 0 ]]; then
            if [[ -z $(smartctl -H /dev/${dev} | grep PASSED) ]]; then
                echo "255 0 0" > /sys/class/leds/$led/color
                echo Disk failure detected on /dev/$dev at $(date +%Y-%m-%d' '%H:%M:%S)
                continue
            fi
        fi

        diskio_new_r=$(cat /sys/block/${dev}/stat | awk '{ print $1 }')
        diskio_new_w=$(cat /sys/block/${dev}/stat | awk '{ print $5 }')

        if [ "${diskio_old_r}" != "${diskio_new_r}" ] || [ "${diskio_old_w}" != "${diskio_new_w}" ]; then
            echo 1 > /sys/class/leds/$led/shot
        fi

        diskio_data_r[$led]=$diskio_new_r
        diskio_data_w[$led]=$diskio_new_w
    done

    if [ -f /usr/bin/zpool-leds.sh ]; then
        bash /usr/bin/zpool-leds.sh
    fi

    sleep 0.1
    loop_cnt=$(($loop_cnt+1))
    loop_cnt=$(($loop_cnt%${smart_poll_interval}))

done
